/**
 * @file Implements the IAM Policy Visualizer feature.
 * @description This component allows users to test and audit Google Cloud Platform (GCP) IAM permissions
 * in real-time across a set of specified resources. It has been refactored to use the new abstracted
 * UI framework and communicates with the Backend-for-Frontend (BFF) via GraphQL mutations.
 * @module components/features/IamPolicyVisualizer
 * @see {@link useTestIamPermissionsMutation} for the GraphQL mutation hook.
 * @see {@link @devcore/core-ui} for the atomic UI components used.
 * @see {@link @devcore/composite-ui} for the composite UI components used.
 * @security This component initiates calls to test GCP IAM permissions. The BFF and downstream services
 * must ensure that the user is properly authenticated and authorized to perform these checks. The client
 * never handles GCP credentials directly, relying on the BFF's secure orchestration.
 * @performance The visualization can become slow with a very large number of resource nodes.
 * The primary performance consideration is the latency of the GraphQL mutation, which orchestrates
 * multiple calls to the GCP API. For complex, client-side analysis of large policy sets, logic
 * could be offloaded to a Web Worker managed by the WorkerPoolManager service.
 */

import React, { useState, useCallback, useMemo } from 'react';

// Assumed imports from a new abstracted UI framework and icon library
import { Button } from '../../ui/core/Button';
import { Card, CardHeader, CardContent } from '../../ui/core/Card';
import { Grid, GridItem } from '../../ui/core/Grid';
import { Input } from '../../ui/core/Input';
import { Select } from '../../ui/core/Select';
import { TextArea } from '../../ui/core/TextArea';
import { Title, Text } from '../../ui/core/Typography';
import { Spinner } from '../../ui/core/Spinner';
import { Tag } from '../../ui/core/Tag';
import { ListItem } from '../../ui/core/List';
import { Header } from '../../ui/composite/Header';
import { Container } from '../../ui/composite/Container';
import { Modal } from '../../ui/composite/Modal';
import { GcpIcon, SparklesIcon } from '../icons';

// --- MOCK GraphQL Hook for demonstration ---
// In a real implementation, this would be auto-generated by a GraphQL client.
const useTestIamPermissionsMutation = () => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const [data, setData] = useState<any>(null);

  const mutate = async ({ variables }: { variables: { resources: string[], permissions: string[] } }) => {
    setLoading(true);
    setError(null);
    setData(null);
    try {
      // Simulate network delay and API call
      await new Promise(resolve => setTimeout(resolve, 1500));
      
      // Mocked response structure that the real BFF might return
      const results = variables.resources.map(resource => {
        // Simulate some permissions passing and some failing
        const grantedPermissions = variables.permissions.filter(() => Math.random() > 0.5);
        return {
          resource,
          grantedPermissions,
        };
      });
      setData({ testIamPermissions: results });
      return { data: { testIamPermissions: results } };
    } catch (e: any) {
      setError(e);
      return { error: e };
    } finally {
      setLoading(false);
    }
  };

  return [mutate, { data, loading, error }] as const;
};
// --- END MOCK ---

/** @typedef {'idle' | 'running' | 'completed' | 'error'} Status of the simulation process. */
type SimulationStatus = 'idle' | 'running' | 'completed' | 'error';
/** @typedef {'neutral' | 'pending' | 'success' | 'fail' | 'partial'} Visual status of a resource node. */
type NodeStatus = 'neutral' | 'pending' | 'success' | 'fail' | 'partial';

/**
 * @interface ResourceNode
 * @description Represents a single GCP resource being visualized and tested.
 * @property {string} id - The full resource name (e.g., '//cloudresourcemanager.googleapis.com/projects/my-project').
 * @property {string} name - The short name of the resource (e.g., 'my-project').
 * @property {'project' | 'bucket' | 'instance' | 'unknown'} type - The inferred type of the resource.
 * @property {NodeStatus} status - The current visual and logical status of the node in the simulation.
 * @property {Array<{permission: string; granted: boolean}>} [results] - The detailed results of the permission check.
 */
interface ResourceNode {
    id: string;
    name: string;
    type: 'project' | 'bucket' | 'instance' | 'unknown';
    status: NodeStatus;
    results?: { permission: string; granted: boolean }[];
}

const COMMON_ROLES = {
    'Viewer': ['resourcemanager.projects.get', 'storage.objects.list', 'compute.instances.list'],
    'Editor': ['storage.objects.create', 'storage.objects.delete', 'compute.instances.start', 'compute.instances.stop'],
    'Storage Object Admin': ['storage.objects.create', 'storage.objects.delete', 'storage.objects.get', 'storage.objects.list', 'storage.objects.update'],
};

/**
 * Infers the type of a GCP resource from its full resource name string.
 * @function getResourceType
 * @param {string} resourceId - The full GCP resource name.
 * @returns {ResourceNode['type']} The inferred resource type.
 * @example
 * getResourceType('//storage.googleapis.com/b/my-bucket') // returns 'bucket'
 */
const getResourceType = (resourceId: string): ResourceNode['type'] => {
    if (resourceId.includes('/projects/')) return 'project';
    if (resourceId.includes('/b/')) return 'bucket';
    if (resourceId.includes('/instances/')) return 'instance';
    return 'unknown';
};

/**
 * The IamPolicyVisualizer component provides a UI to test GCP IAM permissions against various resources.
 * It allows users to input resources and permissions, runs a simulation via the BFF, and displays
 * the results in a clear, color-coded visual format.
 *
 * @component
 * @returns {React.ReactElement} The rendered IAM Policy Visualizer feature.
 * @example
 * <IamPolicyVisualizer />
 */
export const IamPolicyVisualizer: React.FC = () => {
    const [resources, setResources] = useState<ResourceNode[]>([]);
    const [newResource, setNewResource] = useState('//cloudresourcemanager.googleapis.com/projects/your-gcp-project-id');
    const [permissions, setPermissions] = useState('storage.objects.get\nstorage.objects.create');
    const [simulationStatus, setSimulationStatus] = useState<SimulationStatus>('idle');
    const [errorMessage, setErrorMessage] = useState('');
    const [selectedNode, setSelectedNode] = useState<ResourceNode | null>(null);

    const [testPermissions, { loading: isSimulating, error: simulationError }] = useTestIamPermissionsMutation();

    const permissionList = useMemo(() => permissions.split('\n').map(p => p.trim()).filter(Boolean), [permissions]);

    /**
     * Adds a new resource to the list of resources to be simulated.
     * @function handleAddResource
     * @returns {void}
     */
    const handleAddResource = () => {
        if (newResource.trim() && !resources.find(r => r.id === newResource)) {
            setResources(prev => [...prev, {
                id: newResource,
                name: newResource.split('/').pop() || newResource,
                type: getResourceType(newResource),
                status: 'neutral',
            }]);
            setNewResource('');
        }
    };

    /**
     * Executes the IAM permission simulation by calling the GraphQL mutation.
     * It updates the state of resource nodes based on the results.
     * @function handleRunSimulation
     * @returns {Promise<void>}
     * @security This function triggers a potentially sensitive operation. It relies on the user being authenticated,
     * which is checked before calling the mutation. The BFF must enforce authorization.
     * @performance This operation's performance depends on the number of resources and permissions being tested,
     * as it may result in multiple downstream API calls from the BFF.
     */
    const handleRunSimulation = useCallback(async () => {
        if (resources.length === 0 || permissionList.length === 0) {
            setErrorMessage('Please add at least one resource and one permission.');
            return;
        }

        setSimulationStatus('running');
        setErrorMessage('');
        setSelectedNode(null);
        setResources(r => r.map(res => ({ ...res, status: 'pending', results: [] })));

        const { data } = await testPermissions({
            variables: {
                resources: resources.map(r => r.id),
                permissions: permissionList
            }
        });

        if (data?.testIamPermissions) {
            const resultsMap = new Map(data.testIamPermissions.map((r: any) => [r.resource, r.grantedPermissions]));
            
            setResources(prevResources => prevResources.map(resource => {
                const grantedPermissions = resultsMap.get(resource.id) || [];
                const permissionResults = permissionList.map(p => ({ permission: p, granted: grantedPermissions.includes(p) }));
                const allGranted = permissionResults.length > 0 && permissionResults.every(r => r.granted);
                const noneGranted = permissionResults.every(r => !r.granted);

                let status: NodeStatus = 'partial';
                if (allGranted) status = 'success';
                if (noneGranted) status = 'fail';

                return { ...resource, status, results: permissionResults };
            }));
            setSimulationStatus('completed');
        } else {
             setSimulationStatus('error');
             setErrorMessage(simulationError?.message || 'An unknown error occurred during simulation.');
             setResources(r => r.map(res => ({ ...res, status: 'fail' })));
        }

    }, [resources, permissionList, testPermissions, simulationError]);
    
    const nodeStatusConfig: Record<NodeStatus, { borderColor: string; tagColor: string; label: string }> = {
        neutral: { borderColor: 'border-border', tagColor: 'default', label: 'Ready' },
        pending: { borderColor: 'border-yellow-500', tagColor: 'warning', label: 'Pending' },
        success: { borderColor: 'border-green-500', tagColor: 'success', label: 'All Granted' },
        fail: { borderColor: 'border-red-500', tagColor: 'danger', label: 'All Denied' },
        partial: { borderColor: 'border-blue-500', tagColor: 'info', label: 'Partial Access' },
    };

    return (
        <Container fullHeight className="p-4 sm:p-6 lg:p-8 flex flex-col">
            <Modal isOpen={!!selectedNode} onClose={() => setSelectedNode(null)} title="Permission Results">
                {selectedNode && (
                    <div className="flex flex-col gap-4">
                        <Title as="h3" size="lg" className="truncate">{selectedNode.name}</Title>
                        <Text size="xs" color="secondary" className="font-mono break-all">{selectedNode.id}</Text>
                        <ul className="space-y-2 max-h-96 overflow-y-auto">
                            {selectedNode.results?.map(res => (
                                <ListItem key={res.permission} className={`flex items-center justify-between p-2 rounded text-sm ${res.granted ? 'bg-green-500/10' : 'bg-red-500/10'}`}>
                                    <Text as="span" className="font-mono">{res.permission}</Text>
                                    <Tag color={res.granted ? 'success' : 'danger'}>{res.granted ? 'GRANTED' : 'DENIED'}</Tag>
                                </ListItem>
                            ))}
                        </ul>
                    </div>
                )}
            </Modal>
            
            <Header
                icon={<GcpIcon />}
                title="GCP IAM Policy Visualizer"
                subtitle="Visually test and audit GCP IAM permissions in real-time across your resources."
            />

            <div className="flex-grow grid grid-cols-1 lg:grid-cols-3 gap-6 min-h-0 mt-6">
                <Card as="aside" className="lg:col-span-1 flex flex-col gap-4 overflow-y-auto p-4">
                    <Title as="h3" size="xl">Simulation Controls</Title>
                    
                    <div>
                        <Text as="label" size="sm" weight="medium">1. Add Resources</Text>
                        <div className="flex gap-1 mt-1">
                            <Input value={newResource} onChange={e => setNewResource(e.target.value)} placeholder="Full GCP resource name..." className="flex-grow text-xs"/>
                            <Button onClick={handleAddResource} variant="primary" size="sm" aria-label="Add Resource">+</Button>
                        </div>
                    </div>
                    
                    <div>
                        <Text as="label" size="sm" weight="medium">2. Define Permission Set</Text>
                        <Select onChange={e => setPermissions(COMMON_ROLES[e.target.value as keyof typeof COMMON_ROLES]?.join('\n') || '')} className="w-full mt-1 text-xs mb-1">
                            <option>Load common role...</option>
                            {Object.keys(COMMON_ROLES).map(r => <option key={r}>{r}</option>)}
                        </Select>
                        <TextArea value={permissions} onChange={e => setPermissions(e.target.value)} placeholder="One permission per line..." className="w-full h-32 text-xs font-mono"/>
                    </div>

                    <Button onClick={handleRunSimulation} disabled={isSimulating} fullWidth icon={isSimulating ? <Spinner /> : <SparklesIcon />}>
                        {isSimulating ? 'Simulating...' : 'Run Simulation'}
                    </Button>
                    
                    {(errorMessage || simulationError) && <Text color="danger" size="sm" className="text-center">{errorMessage || simulationError?.message}</Text>}
                </Card>

                <main className="lg:col-span-2 bg-background-alt overflow-auto relative p-4 rounded-lg border-2 border-dashed border-border">
                    <Grid columns={{ initial: 2, md: 3, lg: 4 }} gap="md">
                        {resources.map(res => {
                            const config = nodeStatusConfig[res.status];
                            return (
                                <Card
                                    key={res.id}
                                    onClick={() => res.results && setSelectedNode(res)}
                                    className={`p-4 transition-all duration-300 border-4 ${config.borderColor} ${res.results ? 'cursor-pointer hover:scale-105' : ''}`}
                                >
                                    <CardHeader>
                                        <Title as="h4" size="md" className="truncate">{res.name}</Title>
                                    </CardHeader>
                                    <CardContent>
                                        <Text size="xs" color="secondary" className="capitalize">{res.type}</Text>
                                        <Tag color={config.tagColor} className="mt-2">{config.label}</Tag>
                                    </CardContent>
                                </Card>
                            );
                        })}
                    </Grid>
                    {resources.length === 0 && <div className="absolute inset-0 flex items-center justify-center text-text-secondary"><Text>Add resources to begin your simulation.</Text></div>}
                </main>
            </div>
        </Container>
    );
};
